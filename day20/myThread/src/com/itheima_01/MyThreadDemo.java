package com.itheima_01;
/*
    进程和线程【理解】
    (1)进程：是正在运行的程序
            是系统进行资源分配和调用的独立单位
            每一个进程都有它自己的内存空间和系统资源
    (2)线程：是进程中的单个顺序控制流，是一条执行路径
            单线程：一个进程如果只有一条执行路径，则称为单线程程序
            多线程：一个进程如果有多条执行路径，则称为多线程程序

    一个进程至少有一个线程在运行，当一个进程中出现了多个线程时，就称这个应用程序是多线程应用程序，每个线程
    在栈区都有自己的执行空间，自己的方法区，自己的变量。

    jvm在启动时，首先有一个主线程，负责程序的执行，调用的是main方法，主线程执行的代码都在main方法中。

    当产生垃圾时，收垃圾的动作，是不需要主线程来完成，因为这样，会出现主线程中的代码执行停止，会去运行垃圾回
    收器代码，效率较低，所以由单独一个线程来负责垃圾回收。

    随机性原理：因为cpu的快速切换造成，哪个线程获取到了cpu执行权，哪个线程就执行。

    两个小问题：
    （1）为什么要重写run()方法？
        因为run()是用来封装【被线程执行的代码】
    （2）run()方法和start()方法的区别？
        run()：封装线程执行的代码，直接调用，相当于普通方法的调用
        start()：启动线程；然后由JVM调用此线程的run()方法

    方式1：继承Thread类
        1:定义一个类MyThread继承Thread类
        2:在MyThread类中重写run()方法
        3:创建MyThread类的对象
        4:启动线程
 */
public class MyThreadDemo {
    public static void main(String[] args) {
        MyThread my1 = new MyThread();
        MyThread my2 = new MyThread();

//        my1.run();//按顺序打印了，并没有乱序，是因为线程根本没有启动，只是相当于运行了子类的run方法
//        my2.run();

        //void start() 导致此线程开始执行; Java虚拟机调用此线程的run方法
        my1.start();
        my2.start();
    }
}
