package com.itheima_12;

/*
    生产者消费者模式是一个十分经典的多线程协作的模式，弄懂生产者消费者问题能够让我们对多线程编程的理解更加深刻。

    所谓生产者消费者问题，实际上主要是包含了两类线程：
        一类是生产者线程用于生产数据
        一类是消费者线程用于消费数据

    为了解耦生产者和消费者的关系，通常会采用【共享的数据区域】，就像是一个仓库
    生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为
    消费者只需要从共享数据区中去获取数据，并不需要关心生产者的行为

    那么生产者和消费者如何进行通信呢？比如共享资源被消耗完，消费者怎么通知生产者生产？
    就需要生产者线程和消费者线程之间交互：等待和唤醒
    Object类的等待和唤醒方法：【方法必须使用在锁中，比如使用在同步代码块中，否则抛异常】
    （1）void wait() 导致当前线程等待，直到【另一个线程】调用该对象的 notify()方法或 notifyAll()方法
    （2）void notify() 唤醒正在等待对象监视器的单个线程
    （3）void notifyAll() 唤醒正在等待对象监视器的所有线程

    wait和sleep的区别：
    （1）传参：wait可以传入时间，也可以无参。如果不指定时间，则需要对应的notify或者notifyAll来唤醒
             sleep必须指定时间，时间到自动从阻塞的状态转成就绪状态
    （2）执行权和锁：被wait的线程会释放执行权，并且释放锁
                  被sleep的线程会释放执行权，不释放锁

    生产者消费者案例中包含的类：
        1:奶箱类(Box)：定义一个成员变量，表示第x瓶奶，提供存储牛奶和获取牛奶的操作
        2:生产者类(Producer)：实现Runnable接口，重写run()方法，调用存储牛奶的操作
        3:消费者类(Customer)：实现Runnable接口，重写run()方法，调用获取牛奶的操作
        4:测试类(BoxDemo)：里面有main方法，main方法中的代码步骤如下
            A:创建奶箱对象，这是共享数据区域
            B:创建生产者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用存储牛奶的操作
            C:创建消费者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用获取牛奶的操作
            D:创建2个线程对象，分别把生产者对象和消费者对象作为构造方法参数传递
            E:启动线程
 */
public class BoxDemo {
    public static void main(String[] args) {
        //创建奶箱对象，这是共享数据区域
        Box b = new Box();

        //创建生产者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用存储牛奶的操作
        Producer p = new Producer(b);
        //创建消费者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用获取牛奶的操作
        Customer c = new Customer(b);

        //创建2个线程对象，分别把生产者对象和消费者对象作为构造方法参数传递
        Thread t1 = new Thread(p);
        Thread t2 = new Thread(c);

        //启动线程
        t1.start();
        t2.start();
    }
}
