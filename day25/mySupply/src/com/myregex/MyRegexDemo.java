package com.myregex;
/*
    【正则表达式】
    1、正则表达式的作用
    （1）校验字符串是否满足规则
    （2）在一段文本中查找满足要求的内容

    2、字符类【只匹配一个字符】   []表示一个范围，只有在范围内的才满足条件
    （1）[abc]：只能取a，b或c中的一个
    （2）[^abc]：不能取a，b和c中的任意一个
    【并集】
    （3）[a-zA-Z]：取值范围为：(a-z)∪(A-Z)【包含端点a和Z】
    （4）[a-d[m-p]]：取值范围为：(a-d)∪(m-p)
    （5）x|X ：写在[]内表示并集，但是在[]外要写|，表示或。例如：[a-d]|[m-p]=[a-d[m-p]]
        注意：使用|描述多种情况满足其中一种即为true，在使用时最好将多种情况用()扩起，以免计算顺序错乱。
        例如：(\d|X|x)
    【交集】
    （5）[a-z&&[def]]:取值范围为：(a-z)∩(def)=def
    【差集】
    （6）[a-z&&[^bc]]:取值范围为：(a-z)∩(^bc)=(a)∪(d-z)=[ad-z]
    （7）[a-z&&[^m-p]]:取值范围为：(a-z)∩(^m-p)=(a-l)∪(q-z)=[a-lq-z]
   ※注意：[]只能匹配一个字符，如果想要逐个匹配多个字符，那么需要匹配几个字符，就写几个[]

   3、预定义字符【只能匹配一个字符】
    （1）.  :表示任何字符，注意：\n回车符号不匹配
    （2）\d :表示一个数字，相当于[0-9]
    （3）\D :表示非熟悉，相当于[^0-9]
    （4）\s :表示空白字符，相当于\t\n\x0B\f\r
    （5）\S :表示非空白字符，相当于[^\s]
    （6）\w :表示字母、数字、下划线，相当于[a-zA-Z_0-9]
    （7）\W :表示非字母、数字、下划线，相当于[^\w]
    注意：（1）预定义字符只能匹配一个字符，如果想要逐个匹配多个字符，那么需要匹配几个字符，就需要几个预定义字符与之匹配。
         （2）\大写，与\小写，意思相反，表示非
         （3）"\" 是转义字符，即改变后面哪个字符原本的含义。简单来记：两个\表示一个\

    4、数量词【匹配多个字符】
    （1）X? :X表示任意内容，出现0次或一次
    （2）X* :X表示任意内容，出现0次或多次
    （3）X+ :X表示任意内容，出现1次或多次
    （4）X{n} :X表示任意内容，恰好出现n次
    （5）X{n,} :X表示任意内容，出现次数>=n
    （6）X{n,m}:X表示任意内容，出现n<=次数<=m

    5、组：a(bc)+ ：表示bc这个整体重复至少1次
    （1）组就是()
    （2）每组都是有组号的，也就是序号
    （3）组号从1开始，连续不间断
    （4）以左括号为基准，最左边的是第一组，其次为第二组，以此类推。
        例如：(a(b))(c) 组1：(a(b)) 组2：(b) 组3：(c)
        组号规律：从左往右数左括号，数到一个就是一组，依次递增
    （5）捕获分组：①表示后续还要使用本组的数据
                ②正则内部使用：\\组号
                ③正则外部使用：$组号
    （6）非捕获分组：分组之后不需要再用本组数据，仅仅是把数据括起来【比如考虑运算优先级时，使用()】
        ①?:    表示获取全部数据  例如：Java(?:8|11|17)=Java[8|11|17]，其中?代表()前的内容，即Java，也就是说?:可以省略
        ②?=    表示获取前面 部分  例如：Java(?=8|11|17)，获取Java8 Java11 Java17中的Java。
                在获取过程中获取的是Java[8|11|17]这个整体，只是截取()前面的内容返回。
        ③?!    表示获取不是指定内容的前面部分 例如：Java(!=8|11|17)，获取不是Java8 Java11 Java17文本中的Java
        ④不占用组号
    6、忽略大小写：(?i)忽略后面的字符的大小写

    7、String类中使用regex的方法
    boolean matches(String regex) 告诉这个字符串是否匹配给定的 regular expression
    String[] split(String regex) ：按照正则表达式描述的规则切割字符串
    String replaceAll(String regex, String replacement) ：符合正则表达式描述的部分会被replacement全部替换掉
    String replaceFirst(String regex, String replacement) ：只替换第一个符合正则规则的字符串

 */
public class MyRegexDemo {
    public static void main(String[] args) {
        System.out.println("aa".matches("[abc]"));//false,一个[]只能匹配一个字符
        System.out.println("aa".matches("[abc][abc]"));//ture
        System.out.println("0".matches("[0-9]"));//true
        //细节：如果要求两个范围的交集，那么需要写符号&&
        //如果写成了一个&，那么此时&表示就不是交集了，而是一个简简单单的&符号
        System.out.println("a".matches("[a-z&[def]]"));//true,表示单个字符可以是[a-z] & [def]
        System.out.println("a".matches("[a-z&&[def]]"));//false
        System.out.println("&".matches("[a-z&[def]]"));//true
        System.out.println("&".matches("[a-z&&[def]]"));//false,表示单个字符可以是[a-z][def]

        System.out.println("b".matches("[a-d[^bc]]"));//true,两个条件是并集，并之后就相当与无筛选了，结果一直为true

        //转移字符
        System.out.println("\f"+1);
        // " 在java中表示字符串的开头或者结尾
        //此时\表示转义字符，改变了后面那个双引号原本的含义，把他变成了一个普普通通的双引号而已。
        System.out.println("\"");
        // \ 在java中表示转义字符
        // \\ 前面的\是一个转义字符，改变了后面\原本的含义，把他变成一个普普通通的\而已。
        System.out.println("\\");

        System.out.println("你".matches(".."));//false 需要匹配两个字符
        System.out.println("0".matches("\\d"));//true
        System.out.println(".".matches("\\."));

        System.out.println("2o32d".matches("\\w{5,}"));//true
        System.out.println("2o32d".matches("\\w{1,5}"));//true

        //24小时的正则表达式 23:11:11
        String regex4="([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";

        System.out.println("0".matches("[\\dXx]"));//和下面一行语句相同
        System.out.println("9".matches("\\d|X|x"));//| 表示或的关系，三种情况符合一种就匹配成功
        //忽略大小写的书写方式
        //在匹配的时候忽略abc的大小写
        String regex5="(?i)abc";//忽略abc的大小写
        String regex6="a((?i)b)c";//ac小写，忽略b的大小写

        //编写正则的小心得：
        //第一步：按照正确的数据进行拆分
        //第二步：找每一部分的规律，并编写正则表达式
        //第三步：把每一部分的正则拼接在一起，就是最终结果
        //书写的时候：从左到右书写。一位一位的去描述，重复的部分用组()括起来

        //身份证号严格校验 410801 1993 02 28 457x
        //前面6位：省份，市区，派出所等信息，第一位不能是0，后面5位是任意数字
        //年的前半段：18 19 20
        //年的后半段：任意数字出现两次
        //月：01~09 10 11 12
        //日：01~31
        //后面4位：任意数字出现3次，最后一位可以是数字也可以是大写X或者小写x

        String regex7="[1-9]\\d{5}(18|19|20)\\d{2}(0[1-9]|1[0-2])(0[1-9]|[1-2]\\d|3[01])\\d{3}[\\d(?i)x]";
        System.out.println("41080119930228457x".matches(regex7));
        System.out.println("18".matches("[181920]"));//false，超过9以后，这样写代表 0 1 2 8 9中的任意一个

        //分组捕获
        //需求1：判断一个字符串的开始字符和结束字符是否一致？只考虑一个字符
        //举例：a123a  b456b  17891  &abc&  a123b(false)
        // \\组号：表示把第X组的内容再出来用一次
        String regex8="(.).+\\1";

        //需求2：判断一个字符串的开始字符和结束字符是否一致？考虑多个字符
        //举例：abc123abc b456b 123789123 &!@abc&!@ abc343abd(false)
        String regex9="(.+).+\\1";

        //需求3：判断一个字符串的开始部分和结束部分是否一致？开始部分内部每个字符也需要一致
        //举例：aaa123aaa bbb456bbb 111789111 &&ab&&
        //当看到需求中，出现”一致“，就考虑分组
        //(.)：把首字母看作一组
        //\\2:把首字母拿出来再用一次
        // *：表示后面重复的内容出现0次或多次
        String regex10="((.)\\2*).+\\1";

        //正则表达式外使用组号
        //需求4：去掉重复字符
        //举例：我要要学学学编编编编编程程程程程程程程   去重为：我要学编程
        //(.)：把重复内容的第一个字符看作一组
        //\\1：表示第一个字符再次出现
        //+：至少一次
        //$1：表示把正则表达式中的第一组的内容，再拿出来使用
        String s1="我要要学学学编编编编编程程程程程程程程";
        System.out.println(s1.replaceAll("(.)\\1+","$1"));
    }
}
